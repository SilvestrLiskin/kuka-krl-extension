&ACCESS RVP
&REL 1
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM EDITMASK = *

; ============================================================================
; KRL Extension Test File v1.5.0
; This file tests all syntax highlighting, snippets, and completions
; ============================================================================

;FOLD DECLARATIONS
DECL INT counter, index, result
DECL REAL velocity, DISTANCE, angle
DECL BOOL isReady, hasError
DECL CHAR buffer[256]
DECL STRING text[128]
DECL E6POS point1, point2, target
DECL E6AXIS homePos, currentAxes
DECL FRAME baseFrame, toolFrame
DECL AXIS jointAngles
;ENDFOLD

;FOLD INITIALIZATION
DEF TestProgram()
    ; Initialize motion parameters
    BAS(#INITMOV, 0)

    ; Set velocity and acceleration
    $VEL.CP = 0.5           ;m/s - cartesian velocity
    $VEL.ORI1 = 100         ;% - swivel velocity
    $VEL.ORI2 = 100         ;% - rotational velocity
    $ACC.CP = 1.0           ;m/sÂ² - cartesian acceleration
    $ACC.ORI1 = 100         ;% - swivel acceleration
    $ACC.ORI2 = 100         ;% - rotational acceleration

    ; PTP velocity settings
    $VEL_AXIS[1] = 100      ;% axis velocity
    $ACC_AXIS[1] = 100      ;% axis acceleration

    ; Approximation settings
    $APO.CDIS = 50          ;mm - distance approximation
    $APO.CORI = 50          ;deg - orientation approximation
    $APO.CVEL = 50          ;% - velocity approximation

    ; Override
    $OV_PRO = 100
    ;ENDFOLD

    ;FOLD POINT DECLARATIONS
    ; E6POS with STATUS and TURN
    point1 = {E6POS: X 500, Y 0, Z 300, A 0, B 90, C 0, S 2, T 35}
    point2 = {E6POS: X 600, Y 100, Z 350, A 0, B 90, C 0, S 2, T 35}

    ; E6AXIS declaration
    homePos = {E6AXIS: A1 0, A2 -90, A3 90, A4 0, A5 0, A6 0}

    ; FRAME declaration
    baseFrame = {FRAME: X 0, Y 0, Z 0, A 0, B 0, C 0}

    ; Using TOOL and BASE
    $TOOL = TOOL_DATA[1]
    $BASE = BASE_DATA[1]
    ;ENDFOLD

    ;FOLD MOTION COMMANDS
    ; PTP motion
    PTP homePos

    ; LIN motion with approximation
    LIN point1 C_DIS

    ; CIRC motion
    CIRC point1, point2, CA 180.0

    ; Relative motions
    PTP_REL {A1 10}
    LIN_REL {X 50}

    ; Spline motions
    SPTP point1
    SLIN point2
    ;ENDFOLD

    ;FOLD CONTROL STRUCTURES
    ; IF statement
    IF isReady == TRUE THEN
        counter = counter + 1
    ELSE
        hasError = TRUE
    ENDIF

    ; FOR loop
    FOR index = 1 TO 10 STEP 1
        velocity = velocity + 0.1
    ENDFOR

    ; WHILE loop
    WHILE counter < 100
        counter = counter + 1
        WAIT SEC 0.1
    ENDWHILE

    ; REPEAT loop
    REPEAT
        DISTANCE = DISTANCE_POINT_POINT(point1, point2)
    UNTIL DISTANCE < 10

    ; SWITCH statement
    SWITCH counter
    CASE 1
        result = 10
    CASE 2
        result = 20
    DEFAULT
        result = 0
    ENDSWITCH

    ; LOOP (infinite)
    LOOP
        WAIT FOR $IN[1] == TRUE
        EXIT
    ENDLOOP
    ;ENDFOLD

    ;FOLD OPERATORS
    ; Arithmetic operators
    result = (counter + 10) * 2 - 5 / 2

    ; Comparison operators
    isReady = (counter == 10) AND (velocity > 0.5)
    hasError = (index <> 0) OR (DISTANCE >= 100)

    ; Logical operators
    isReady = NOT hasError
    result = counter AND index
    result = counter OR index
    result = counter EXOR index

    ; Bitwise operators
    result = B_AND(counter, 255)
    result = B_OR(counter, 128)
    result = B_NOT(counter)
    result = B_XOR(counter, index)
    result = B_EXOR(counter, index)
    ;ENDFOLD

    ;FOLD SYSTEM VARIABLES
    ; Motion system variables
    velocity = $VEL.CP
    currentAxes = $AXIS_ACT
    point1 = $POS_ACT

    ; Mode and state
    IF $MODE_OP == #T1 THEN
        ; Test mode 1
    ENDIF

    IF $PRO_STATE0 == #P_ACTIVE THEN
        ; Program active
    ENDIF

    ; Timer
    $TIMER[1] = 0
    $TIMER_FLAG[1] = TRUE
    $TIMER_STOP[1] = FALSE

    ; I/O
    $OUT[1] = TRUE
    isReady = $IN[1]
    velocity = $ANIN[1]
    $ANOUT[1] = 5.0
    ;ENDFOLD

    ;FOLD CHANNEL COMMUNICATION
    DECL INT handle
    DECL STATE_T state
    DECL CHAR response[256]

    ; Open channel
    COPEN(:handle, state)
    IF state.RET1 == #CMD_OK THEN
        ; Write request
        CWRITE(handle, state, #COND, "%S", "REQUEST")

        ; Read response
        CREAD(handle, state, #COND, 1000, 0, "%S", response[])
        IF state.RET1 == #CMD_OK THEN
            ; Process response
        ENDIF

        ; Close channel
        CCLOSE(handle, state)
    ENDIF
    ;ENDFOLD

    ;FOLD WONDERLIBRARY FUNCTIONS
    ; Geometry functions
    DISTANCE = DISTANCE_POINT_POINT(point1, point2)

    ; String functions
    text[] = SPRINTF("Position: X=%.2f Y=%.2f", point1.X, point1.Y)
    velocity = STOF("123.456")
    counter = STOI("42")

    ; Math functions
    isReady = IN_RANGE(velocity, 0.0, 1.0)
    hasError = IN_TOLERANCE(DISTANCE, 100.0, 5.0)

    ; Logical functions
    point1 = BOOL_CHOOSE_E6POS(isReady, point1, point2)
    ;ENDFOLD

    ;FOLD BUILT-IN FUNCTIONS
    ; Math functions
    angle = SIN(90)
    angle = COS(0)
    angle = TAN(45)
    angle = ATAN2(1, 1)
    angle = SQRT(144)
    angle = ABS(-50)

    ; String functions
    counter = StrLen(text[])
    StrCopy(buffer[], text[])

    ; Inverse kinematics
    currentAxes = INVERSE(point1)
    point1 = FORWARD(currentAxes)
    ;ENDFOLD

    ;FOLD INTERRUPTS AND TRIGGERS
    ; Interrupt declaration
    INTERRUPT DECL 1 WHEN $IN[1] == TRUE DO EmergencyStop()
    INTERRUPT ON 1

    ; Trigger
    TRIGGER WHEN DISTANCE = 0 DELAY = 0 DO $OUT[1] = TRUE

    ; Signal
    SIGNAL gripper $OUT[1]
    gripper = TRUE
    ;ENDFOLD

    ;FOLD WAIT COMMANDS
    ; Wait for time
    WAIT SEC 1.0

    ; Wait for condition
    WAIT FOR $IN[1] == TRUE

    ; Halt and brake
    ; HALT
    ; BRAKE
    ;ENDFOLD

    ;FOLD ANALOG I/O
    ; Analog input
    ANIN ON velocity = 1.0 * $ANIN[1] + 0.0
    ANIN OFF velocity

    ; Analog output
    ANOUT ON $ANOUT[1] = 1.0 * velocity + 0.0
    ANOUT OFF $ANOUT[1]
    ;ENDFOLD

    ;FOLD STATUS AND TURN DOCUMENTATION
    ;STATUS (S) Bit meanings:
    ;  B0: Wrist root point position (0=basic area, 1=overhead area)
    ;  B1: Arm configuration (0=elbow up, 1=elbow down)
    ;  B2: Wrist configuration (0=wrist up, 1=wrist down)
    ;Example: S = 'B010' or S = 2

    ;TURN (T) Bit meanings for axis angles:
    ;  B0: A1 < 0 (true=1)
    ;  B1: A2 < 0 (true=1)
    ;  B2: A3 < 0 (true=1)
    ;  B3: A4 < 0 (true=1)
    ;  B4: A5 < 0 (true=1)
    ;  B5: A6 < 0 (true=1)
    ;Example: T = 'B000001' or T = 1 (A1 negative)
    ;ENDFOLD

    ;FOLD ENUM VALUES TEST
    ; Motion enums
    ; #BASE, #PATH, #FORWARD, #BACKWARD, #TCP
    ; #VAR, #CONSTANT, #JOINT
    ; #SOURCE, #BEST
    ; #WORLD, #ROBROOT

    ; System enums
    ; #T1, #T2, #AUT, #EX
    ; #P_FREE, #P_RESET, #P_ACTIVE, #P_STOP, #P_END
    ; #ISTEP, #PSTEP, #MSTEP, #CSTEP, #GO, #BSTEP
    ; #BUSY, #IDLE, #CANCELLED, #PEND

    ; Channel enums
    ; #CMD_OK, #CMD_ABORT, #COND, #SYNC, #ASYNC
    ;ENDFOLD

END

;FOLD SUBPROGRAMS
DEF EmergencyStop()
    BRAKE
    $OUT[1] = FALSE
    HALT
END

DEFFCT REAL CalculateDistance(p1:IN, p2:IN)
    DECL E6POS p1, p2
    DECL REAL dist

    dist = SQRT((p2.X - p1.X)^2 + (p2.Y - p1.Y)^2 + (p2.Z - p1.Z)^2)
    RETURN dist
ENDFCT
;ENDFOLD
